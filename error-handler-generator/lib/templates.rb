# frozen_string_literal: true

module ErrorGen
  module Templates
    def get_error_groups_count(errors)
      errors.length
    end

    def get_error_instances_count(errors)
      # Sum all the instances of each error to get the total
      errors.map(&:instances).inject(0, &:+)
    end

    def get_error_groups_count_name(prefix: nil)
      to_upcase('error_group_count', prefix: prefix)
    end

    def sanitize(str)
      if str.nil?
        return nil
      end
      res = str
      # If string start with number add an underscore
      if str.match(/\A\d/)
        res = '_' + str
      end
      # Replace spaces and hypens with underscores and remove every other
      # character that is not alphanumeric
      res.downcase.gsub('-', '_').gsub(' ', '_').delete('^a-z0-9_').to_s
    end

    def to_downcase(str, prefix: nil, suffix: nil)
      # Sanitize strings
      s_prefix = sanitize(prefix)
      s_str = sanitize(str)
      s_suffix = sanitize(suffix)

      s_prefix&.+('_').to_s + s_str.to_s + s_suffix&.prepend('_').to_s
    end

    def to_upcase(str, prefix: nil, suffix: nil)
      # Sanitize strings
      s_prefix = sanitize(prefix)
      s_str = sanitize(str)
      s_suffix = sanitize(suffix)

      s_prefix&.+('_')&.upcase.to_s + s_str.upcase.to_s + s_suffix&.prepend('_')&.upcase.to_s
    end

    # If str is already camelcase the sanitize function will change the string to
    # lower case which is then camelized (e.g. CamelCase -> Camelcase)
    def to_camelcase(str, prefix: nil, suffix: nil)
      # Sanitize strings
      s_prefix = sanitize(prefix)
      s_str = sanitize(str)
      s_suffix = sanitize(suffix)

      s_prefix&.camelize.to_s + s_str.camelize.to_s + s_suffix&.camelize.to_s
    end

    def to_str_list(errors, each, all)
      list = []
      errors.each do |error|
        list.push(each.(error))
      end
      all.(list).to_s
    end

    HEADER = <<~BANNER
      /*******************************************************************************
       * Critical error handler library generator
       * Generated by error_gen ruby gem, for more information see:
       * https://github.com/eagletrt/micro-utils/tree/master/error-handler-generator
       *
       * Error_gen version <%= ErrorGen::VERSION %>
       * Generation date: <%= Time.now %>
       * Generated from: <%= @jsonfile %>
       * With prefix: <%= @prefix ? sanitize(@prefix) : 'none' %>
       * The error handler contains:
       *     - <%= get_error_groups_count(@errors) %> error groups
       *     - <%= get_error_instances_count(@errors) %> total error instances
       ******************************************************************************/

    BANNER

    HH = <<~HEADER
      <% safeguard = to_upcase(@target_name, suffix: 'h') %>
      #ifndef <%= safeguard %>
      #define <%= safeguard %>

      #include <stdint.h>
      #include <stdbool.h>
      #include <stddef.h>
      <%
        # Types
        error_t = to_camelcase('error', prefix: @prefix)
        group_t = to_camelcase('error_group', prefix: @prefix)
        instance_t = to_camelcase('error_instance', prefix: @prefix)
      %>
      // Total number of error instances
      #define <%= to_upcase('error_instance_count', prefix: @prefix) %> <%= get_error_instances_count(@errors) %>

      /**
       * @brief Set or reset an instance of an error based on a condition
       *
       * @details If the condition is true the error is set, otherwise it is reset
       *
       * @param condition A boolean expression
       * @param group The group to which the error belongs
       * @param instance The instance of the error
       * @param The current time (in ms)
       */
      #define <%= to_upcase('error_toggle_if', prefix: @prefix) %>(condition, group, instance, timestamp) \\
          ((condition) ? <%= to_downcase('error_set', prefix: @prefix) %>(group, instance, timestamp) : <%= to_downcase('error_reset', prefix: @prefix) %>(group, instance))

      /**
       * @brief Type of the error that categorize a group of instances
       *
       * @details
       *     <%=
                # Generate a list of descriptions for the error list
                to_str_list(
                  @errors,
                  lambda { |error| to_upcase('error_group_' + error.name, prefix: @prefix) + ' no description' },
                  lambda { |list| list.join('\n *     ') })
             %>
       */
      typedef enum {
          <%=
            # Generate a list of error groups with a prefix
            to_str_list(
              @errors,
              lambda { |error| to_upcase('error_group_' + error.name, prefix: @prefix) },
              lambda { |list| list.join(',\n    ') })
          %>,
          <%= get_error_groups_count_name(prefix: @prefix) %>
      } <%= group_t %>;

      /** @brief Single error instance type definition */
      typedef uint16_t <%= instance_t %>;

      /**
       * @brief Error type definition
       *
       * @param group The group to which the error belongs
       * @param timestamp The time when the error was set (in ms)
       * @param is_running True if the error is set, false otherwise
       * @param is_expired True if the error has expired, false otherwise
       */
      typedef struct {
          <%= group_t %> group;
          uint32_t timestamp;
          bool is_running;
          bool is_expired;
      } <%= error_t %>;

      /**
       * @brief Initialize the internal error handler structures
       *
       * @details A critical section is defined as a block of code where, if an interrupt
       * happens, undefined behaviour with the modified data within the block can happen
       *
       * @param cs_enter A pointer to a function that should manage a critical section
       * @param cs_exit A pointer to a function that shuold manage a critical section
       */
      void <%= to_downcase('error_init', prefix: @prefix) %>(void (* cs_enter)(void), void (* cs_exit)(void));

      /**
       * @brief Get the number of errors that has been set but they still have to expire
       *
       * @param size_t The number of running errors
       */
      size_t <%= to_downcase('error_get_running', prefix: @prefix) %>(void);

      /**
       * @brief Get the number of expired errors
       *
       * @param size_t The number of expired errors
       */
      size_t <%= to_downcase('error_get_expired', prefix: @prefix) %>(void);

      /**
       * @brief Get the number of running error of a specific group
       *
       * @param group The error group
       *
       * @return uint16_t The number of running errors
       */
      uint16_t <%= to_downcase('error_get_group_running', prefix: @prefix) %>(<%= group_t %> group);

      /**
       * @brief Get the number of expired error of a specific group
       *
       * @param group The error group
       *
       * @return uint16_t The number of running errors
       */
      uint16_t <%= to_downcase('error_get_group_expired', prefix: @prefix) %>(<%= group_t %> group);

      /**
       * @brief Get a copy of all the errors that are currently running
       *
       * @attention This function can be quite expensive in terms of time
       * and should be used wisely, do not call to often
       * @attention This function calls the critical section handler functions
       *
       * @details The out array should be able to contain all the instances
       *
       * @param out A pointer to an array of errors where the data is copied into
       *
       * @return size_t The number of copied errors
       */
      size_t <%= to_downcase('error_dump_running', prefix: @prefix) %>(<%= error_t %> * out);

      /**
       * @brief Get a copy of all the errors that are expired
       *
       * @attention This function can be quite expensive in terms of time
       * and should be used wisely, do not call to often
       * @attention This function calls the critical section handler functions
       *
       * @details The out array should be able to contain all the instances
       *
       * @param out A pointer to an array of errors where the data is copied into
       *
       * @return size_t The number of copied errors
       */
      size_t <%= to_downcase('error_dump_expired', prefix: @prefix) %>(<%= error_t %> * out);

      /**
       * @brief Get all the groups in which at least one error is running
       *
       * @param out A pointer to an array of groups where the data is copied into
       *
       * @return size_t The number of copied groups
       */
      size_t <%= to_downcase('error_dump_running_groups', prefix: @prefix) %>(<%= group_t %> * out);

      /**
       * @brief Get all the groups in which at least one error is expired
       *
       * @param out A pointer to an array of groups where the data is copied into
       *
       * @return size_t The number of copied groups
       */
      size_t <%= to_downcase('error_dump_expired_groups', prefix: @prefix) %>(<%= group_t %> * out);

      /**
       * @brief Set an error which will expire after a certain amount of time (the timeout)
       *
       * @param group The group to which the error belongs
       * @param instance The instance of the error
       * @param The current time (in ms)
       */
      void <%= to_downcase('error_set', prefix: @prefix) %>(<%= group_t %> group, <%= instance_t %> instance, uint32_t timestamp);

      /**
       * @brief Reset an error to avoid its expiration
       *
       * @param group The group to which the error belongs
       * @param instance The instance of the error
       */
      void <%= to_downcase('error_reset', prefix: @prefix) %>(<%= group_t %> group, <%= instance_t %> instance);

      /** @brief Set the error as expired */
      void <%= to_downcase('error_expire', prefix: @prefix) %>(void);

      /**
       * @brief Set the error as expired immediately even if it is not running
       *
       * @param group The group to which the error belongs
       * @param instance The instance of the error
       */
      void <%= to_downcase('error_expire_immediate', prefix: @prefix) %>(<%= group_t %> group, <%= instance_t %> instance);

      /**
       * @brief Routine that updates the internal error states
       *
       * @attention This function should not be called inside interrupts callback
       * or other threads
       *
       * @details This function should be called periodically
       */
      void <%= to_downcase('error_routine', prefix: @prefix) %>(void);

      /**
       * @brief Update the timer that should expire the error after a certain amount of time
       *
       * @attention This function have to be defined by the user
       *
       * @details This function is called internally when an error is set, reset or expired
       *
       * @param timestamp The time in which the error was set (in ms)
       * @param timeout The time that should elapse after the timestamp to expire the error (in ms)
       */
      void <%= to_downcase('error_update_timer_callback', prefix: @prefix) %>(uint32_t timestamp, uint16_t timeout);

      /**
       * @brief Stop the timer that should expire the errors
       *
       * @attention This function have to be defined by the user
       *
       * @details This function is called internally when an error is reset or expired
       */
      void <%= to_downcase('error_stop_timer_callback', prefix: @prefix) %>(void);

      #endif  // <%= safeguard %>

    HEADER

    # TODO: Add general error that expire immediately if something goes wrong in this library
    # TODO: Add callback that is called after an error is expired an give useful info
    #       about it as a parameter
    # TODO: Better find function (apply heuristics to reduce complexity)
    # TODO: Remove element without index in O(log N)
    CC = <<~SOURCE
      #include "<%= @target_name %>.h"

      #include <string.h>

      #include "ring-buffer.h"
      #include "min-heap.h"
      <%
        # Types
        error_t = to_camelcase('error', prefix: @prefix)
        group_t = to_camelcase('error_group', prefix: @prefix)
        instance_t = to_camelcase('error_instance', prefix: @prefix)
        data_t = to_camelcase('error_data', prefix: @prefix)
      %>
      // Ring buffer maximum number of elements
      #define <%= to_upcase('error_buffer_size', prefix: @prefix) %> 16

      /**
       * @brief Error data type definition needed to manage the errors
       *
       * @param group The group to which the error belongs
       * @param instance The instance of the error
       * @param timestamp The current time (in ms)
       * @param op A pointer to the operation that needs to be executed
       */
      typedef struct _<%= data_t %> {
          <%= group_t %> group;
          <%= instance_t %> instance;
          uint32_t timestamp;
          void (* op)(struct _<%= data_t %>);
      } <%= data_t %>;

      /** @brief Total number of instances for each group */
      static const uint16_t instances[] = {
          <%=
            # Generate a list of number of instances for each group
            to_str_list(
              @errors,
              lambda { |error| '[' + to_upcase('error_group_' + error.name, prefix: @prefix) + '] = ' + error.instances.to_s },
              lambda { |list| list.join(',\n    ') })
          %>
      };
      /** @brief Error timeout for each group */
      static const uint16_t timeouts[] = {
          <%=
            # Generate a list of timeouts for each group
            to_str_list(
              @errors,
              lambda { |error| '[' + to_upcase('error_group_' + error.name, prefix: @prefix) + '] = ' + error.timeout.to_s },
              lambda { |list| list.join(',\n    ') })
          %>
      };

      /** @brief List of errors where the data is stored */
      <%=
        # Generate a list of arrays of errors for each group
        to_str_list(
          @errors,
          lambda { |error| 'static ' + error_t + ' ' + to_downcase('error_' + error.name + '_instances', prefix: @prefix) + '[' + error.instances.to_s + '];' },
          lambda { |list| list.join('\n') })
      %>
      static <%= error_t %> * errors[] = {    
          <%=
            # Assign the corresponding instances array to each group
            to_str_list(
              @errors,
              lambda { |error| '[' + to_upcase('error_group_' + error.name, prefix: @prefix) + '] = ' + to_downcase('error_' + error.name + '_instances', prefix: @prefix) },
              lambda { |list| list.join(',\n    ') })
          %>
      };

      /** @brief Function declaration needed for the min heap */
      int8_t _<%= to_downcase('error_compare', prefix: @prefix) %>(void * a, void * b);

      bool routine_lock = false;
      RingBuffer(<%= data_t %>, <%= to_upcase('error_buffer_size', prefix: @prefix) %>) err_buf;
      RingBuffer(<%= error_t %> *, <%= to_upcase('error_instance_count', prefix: @prefix) %>) expired_errors = ring_buffer_new(<%= error_t %> *, <%= to_upcase('error_instance_count', prefix: @prefix) %>, NULL, NULL);
      MinHeap(<%= error_t %> *, <%= to_upcase('error_instance_count', prefix: @prefix) %>) running_errors = min_heap_new(<%= error_t %> *, <%= to_upcase('error_instance_count', prefix: @prefix) %>, _<%= to_downcase('error_compare', prefix: @prefix) %>);

      /** @brief Fast lookup for groups that are running or expired */
      uint16_t running_groups[<%= get_error_groups_count_name(prefix: @prefix) %>];
      uint16_t expired_groups[<%= get_error_groups_count_name(prefix: @prefix) %>];

      /**
       * @brief Compare two errors based on the time when they were set
       * and their timeouts
       *
       * @param t1 The timestamp of the first error
       * @param dt1 The timeout of the first error
       * @param t2 The timestamp of the second error
       * @param dt2 The timeout of the second error
       * @return int32_t The difference between the two expire times
       */
      int8_t _<%= to_downcase('error_compare', prefix: @prefix) %>(void * a, void * b) {
          <%= error_t %> * e1 = *(<%= error_t %> **)a;
          <%= error_t %> * e2 = *(<%= error_t %> **)b;
          int32_t t1 = e1->timestamp + timeouts[e1->group];
          int32_t t2 = e2->timestamp + timeouts[e2->group];
          return t1 < t2 ? -1 : (t1 == t2 ? 0 : 1);
      }

      /**
       * @brief Set the error if possible and update the timer if necessary
       *
       * @param data The data of the error to set
       */
      void _<%= to_downcase('error_set', prefix: @prefix) %>(<%= data_t %> data) {
          // Get error
          <%= error_t %> * err = &errors[data.group][data.instance];
          if (err->is_running || err->is_expired)
              return;

          // Update error info
          err->is_running = true;
          err->timestamp = data.timestamp;
          ++running_groups[data.group];

          // Add error to the running list of errors and
          // update timer if the error is the first to expire
          if (min_heap_insert(&running_errors, &err) != MIN_HEAP_OK)
              return;
          <%= error_t %> ** top = (<%= error_t %> **)min_heap_peek(&running_errors);
          if (top != NULL && *top == err)
              <%= to_downcase('error_update_timer_callback', prefix: @prefix) %>(err->timestamp, timeouts[err->group]);
      }

      /**
       * @brief Reset the error if possible and update the timer if necessary
       *
       * @param data The data of the error to reset
       */
      void _<%= to_downcase('error_reset', prefix: @prefix) %>(<%= data_t %> data) {
          // Get error
          <%= error_t %> * err = &errors[data.group][data.instance];
          if (!err->is_running || err->is_expired)
              return;

          // Update error info
          err->is_running = false;
          --running_groups[data.group];

          // Get the current first element
          <%= error_t %> * top = NULL;
          if (min_heap_top(&running_errors, &top) != MIN_HEAP_OK)
              return;

          if (top == err) {
              // If the removed error is the first in the heap
              // remove it and update (or stop) the timer
              if (min_heap_remove(&running_errors, 0, NULL) != MIN_HEAP_OK)
                  return;

              if (min_heap_is_empty(&running_errors))
                  <%= to_downcase('error_stop_timer_callback', prefix: @prefix) %>();
              else if (min_heap_top(&running_errors, &top) == MIN_HEAP_OK)
                  <%= to_downcase('error_update_timer_callback', prefix: @prefix) %>(top->timestamp, timeouts[top->group]);
          }
          else {
              // Find and remove the error
              signed_size_t i = min_heap_find(&running_errors, &err);
              if (i < 0) return;
              min_heap_remove(&running_errors, i, NULL);
          }
      }

      /**
       * @brief Expire the error
       *
       * @param data The data of the error to expire
       */
      void _<%= to_downcase('error_expire', prefix: @prefix) %>(<%= data_t %> data) {
          // Get error
          <%= error_t %> * top = NULL;
          if (min_heap_top(&running_errors, &top) != MIN_HEAP_OK)
              return;

          if (!top->is_running || top->is_expired)
              return;

          <%= error_t %> * prev = top;
          do {
              // Update error info
              top->is_running = false;
              top->is_expired = true;
              --running_groups[data.group];
              ++expired_groups[data.group];

              // Add error to the list of expired errors
              if (ring_buffer_push_back(&expired_errors, &top) != RING_BUFFER_OK)
                  break;

              // Get next error and remove the previous
              if (min_heap_remove(&running_errors, 0, NULL) != MIN_HEAP_OK)
                  break;

              // Stop the timer if there are no more errors
              if (min_heap_is_empty(&running_errors)) {
                  <%= to_downcase('error_stop_timer_callback', prefix: @prefix) %>();
                  return;
              }

              // Get next errors
              if (min_heap_top(&running_errors, &top) != MIN_HEAP_OK)
                  break;
          } while(_<%= to_downcase('error_compare', prefix: @prefix) %>(&top, &prev) <= 0);

          // Update the timer
          if (top != NULL)
              <%= to_downcase('error_update_timer_callback', prefix: @prefix) %>(top->timestamp, timeouts[top->group]);
      }
      /**
       * @brief Expire the error immediately without waiting for the timer
       *
       * @param data The data of the error to expire
       */
      void _<%= to_downcase('error_expire_immediate', prefix: @prefix) %>(<%= data_t %> data) {
          // Get error
          <%= error_t %> * err = &errors[data.group][data.instance];
          if (err->is_expired)
              return;

          // Update error info
          err->is_running = false;
          err->is_expired = true;
          --running_groups[data.group];
          ++expired_groups[data.group];

          // Add error to the list of expired errors
          if (ring_buffer_push_back(&expired_errors, &err) != RING_BUFFER_OK)
              break;

          // Remove the error from the list of running errors
          signed_size_t index = min_heap_find(&running_errors, &err);
          if (index < 0)
              return;
          if (min_heap_remove(&running_errors, index, NULL) != MIN_HEAP_OK)
              return;

          // Stop the timer if there are no more errors
          if (min_heap_is_empty(&running_errors)) {
              <%= to_downcase('error_stop_timer_callback', prefix: @prefix) %>();
              return;
          }
          else if (index == 0) {
              // Update the timer with the next error data
              <%= error_t %> ** next = (<%= error_t %> **)min_heap_peek(&running_errors);
              if (next != NULL)
                  <%= to_downcase('error_update_timer_callback', prefix: @prefix) %>((*next)->timestamp, timeouts[(*next)->group]);
          }
      }

      void <%= to_downcase('error_init', prefix: @prefix) %>(void (* cs_enter)(void), void (* cs_exit)(void)) {
          ring_buffer_init(&err_buf, <%= data_t %>, <%= to_upcase('error_buffer_size', prefix: @prefix) %>, cs_enter, cs_exit);

          <%=
            # Initialize all the error instances
            to_str_list(
              @errors,
              lambda { |error|
                'for (size_t i = 0; i < instances[' + to_upcase('error_group_' + error.name, prefix: @prefix) + ']; ++i)\n        ' +
                to_downcase('error_' + error.name + '_instances', prefix: @prefix) + '[i].group = ' + to_upcase('error_group_' + error.name, prefix: @prefix) + ';'
              },
              lambda { |list| list.join('\n    ') })
          %>
      }
      size_t <%= to_downcase('error_get_running', prefix: @prefix) %>(void) {
          return min_heap_size(&running_errors);
      }
      size_t <%= to_downcase('error_get_expired', prefix: @prefix) %>(void) {
          return ring_buffer_size(&expired_errors);
      }
      uint16_t <%= to_downcase('error_get_group_running', prefix: @prefix) %>(<%= group_t %> group) {
          if (group >= <%= get_error_groups_count_name(prefix: @prefix) %>)
              return 0U;
          return running_groups[group];
      }
      uint16_t <%= to_downcase('error_get_group_expired', prefix: @prefix) %>(<%= group_t %> group) {
          if (group >= <%= get_error_groups_count_name(prefix: @prefix) %>)
              return 0U;
          return expired_groups[group];
      }
      size_t <%= to_downcase('error_dump_running', prefix: @prefix) %>(<%= error_t %> * out) {
          if (out == NULL)
              return 0U;

          err_buf.cs_enter();
          // Copy data
          size_t i;
          for (i = 0; i < running_errors.size; ++i)
              memcpy(&out[i], running_errors.data[i], sizeof(out[0U]));
          err_buf.cs_exit();
          return i;
      }
      size_t <%= to_downcase('error_dump_expired', prefix: @prefix) %>(<%= error_t %> * out) {
          if (out == NULL)
              return 0U;

          err_buf.cs_enter();
          // Copy data
          size_t i;
          for (i = 0; i < expired_errors.size; ++i)
              memcpy(&out[i], expired_errors.data[i], sizeof(out[0U]));
          err_buf.cs_exit();
          return i;
      }
      size_t <%= to_downcase('error_dump_running_groups', prefix: @prefix) %>(<%= group_t %> * out) {
          if (out == NULL)
              return 0U;
          // Copy data
          size_t cnt = 0;
          for (size_t i = 0; i < <%= get_error_groups_count_name(prefix: @prefix) %>; ++i)
              if (running_groups[i] > 0)
                  out[cnt++] = i;
          return cnt;
      }
      size_t <%= to_downcase('error_dump_expired_groups', prefix: @prefix) %>(<%= group_t %> * out) {
          if (out == NULL)
              return 0U;
          // Copy data
          size_t cnt = 0;
          for (size_t i = 0; i < <%= get_error_groups_count_name(prefix: @prefix) %>; ++i)
              if (expired_groups[i] > 0)
                  out[cnt++] = i;
          return cnt;
      }
      void <%= to_downcase('error_set', prefix: @prefix) %>(<%= group_t %> group, <%= instance_t %> instance, uint32_t timestamp) {
          if (group >= <%= get_error_groups_count_name(prefix: @prefix) %> || instance >= instances[group])
              return;

          // Push data to the buffer
          <%= data_t %> data = {
              .group = group,
              .instance = instance,
              .timestamp = timestamp,
              .op = _<%= to_downcase('error_set', prefix: @prefix) %>
          };
          if (ring_buffer_push_back(&err_buf, &data) == RING_BUFFER_OK)
              <%= to_downcase('error_routine', prefix: @prefix) %>();
      }
      void <%= to_downcase('error_reset', prefix: @prefix) %>(<%= group_t %> group, <%= instance_t %> instance) {
          if (instance >= instances[group])
              return;

          // Push data to the buffer
          <%= data_t %> data = {
              .group = group,
              .instance = instance,
              .timestamp = 0,
              .op = _<%= to_downcase('error_reset', prefix: @prefix) %>
          };
          if (ring_buffer_push_back(&err_buf, &data) == RING_BUFFER_OK)
              <%= to_downcase('error_routine', prefix: @prefix) %>();
      }
      void <%= to_downcase('error_expire', prefix: @prefix) %>(void) {
          // Push data to the buffer
          <%= data_t %> data = { .op = _<%= to_downcase('error_expire', prefix: @prefix) %> };
          if (ring_buffer_push_back(&err_buf, &data) == RING_BUFFER_OK)
              <%= to_downcase('error_routine', prefix: @prefix) %>();
      }
      void <%= to_downcase('error_expire_immediate', prefix: @prefix) %>(<%= group_t %> group, <%= instance_t %> instance) {
          if (instance >= instances[group])
              return;

          // Push data to the buffer
          <%= data_t %> data = {
              .group = group,
              .instance = instance,
              .op = _<%= to_downcase('error_expire_immediate', prefix: @prefix) %>
          };
          if (ring_buffer_push_back(&err_buf, &data) == RING_BUFFER_OK)
              <%= to_downcase('error_routine', prefix: @prefix) %>();
      }
      void <%= to_downcase('error_routine', prefix: @prefix) %>(void) {
          // Avoid multiple execution of the routine
          if (routine_lock)
              return;
          routine_lock = true;

          // Check if buffer is not empty
          if (ring_buffer_is_empty(&err_buf)) {
              routine_lock = false;
              return;
          }

          // Execute the right function for the error
          <%= data_t %> err;
          if (ring_buffer_pop_front(&err_buf, &err) == RING_BUFFER_OK)
              err.op(err);

          routine_lock = false;
      }

      __attribute__((weak)) void <%= to_downcase('error_update_timer_callback', prefix: @prefix) %>(uint32_t timestamp, uint16_t timeout) { }
      __attribute__((weak)) void <%= to_downcase('error_stop_timer_callback', prefix: @prefix) %>(void) { }

    SOURCE
  end
end
