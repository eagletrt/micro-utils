/*******************************************************************************
 * Critical error handler library generator
 * Generated by error_gen ruby gem, for more information see:
 * https://github.com/eagletrt/micro-utils/tree/master/error-handler-generator
 *
 * Error_gen version 0.1.0-alpha
 * Generation date: 2024-03-19 19:02:48 +0100
 * Generation from: 
 * The error handler contains:
 *     - 3 error groups
 *     - 119 total error instances
 ******************************************************************************/

#include "simple.h"

#include <stddef.h>

#include "ring-buffer.h"
#include "min-heap.h"

// Ring buffer maximum number of elements
#define ERROR_BUFFER_SIZE 16

/**
 * @brief Error data type definition needed to manage the errors
 *
 * @param group The group to which the error belongs
 * @param instance The instance of the error
 * @param timestamp The current time (in ms)
 * @param op A pointer to the operation that needs to be executed
 */
typedef struct _ErrorData {
    ErrorGroup group;
    ErrorInstance instance;
    uint32_t timestamp;
    void (* op)(struct _ErrorData);
} ErrorData;

// Total number of instances for each group
static const uint16_t instances[] = {
    [ERROR_FIRST] = 10,
    [ERROR_SECOND] = 108,
    [ERROR_THIRD] = 1
};
// Error timeout for each group
static const uint16_t timeouts[] = {
    [ERROR_FIRST] = 100,
    [ERROR_SECOND] = 250,
    [ERROR_THIRD] = 2000
};

// Errors information
static Error error_first_instances[10];
static Error error_second_instances[108];
static Error error_third_instances[1];
static Error * errors[] = {
    [ERROR_FIRST] = error_first_instances,
    [ERROR_SECOND] = error_second_instances,
    [ERROR_THIRD] = error_third_instances
};

// Function declaration needed for the min heap
int8_t _error_compare(void * a, void * b);

bool routine_lock = false;
RingBuffer(ErrorData, ERROR_BUFFER_SIZE) err_buf = ring_buffer_init(ErrorData, ERROR_BUFFER_SIZE);
MinHeap(Error *, ERROR_INSTANCE_COUNT) running_errors = min_heap_init(Error *, ERROR_INSTANCE_COUNT, _error_compare);

/**
 * @brief Compare two errors based on the time when they were set
 * and their timeouts
 * 
 * @param t1 The timestamp of the first error
 * @param dt1 The timeout of the first error
 * @param t2 The timestamp of the second error
 * @param dt2 The timeout of the second error
 * @return int32_t The difference between the two expire times
 */
int8_t _error_compare(void * a, void * b) {
    Error * e1 = *(Error **)a;
    Error * e2 = *(Error **)b;
    int32_t t1 = e1->timestamp + timeouts[e1->group];
    int32_t t2 = e2->timestamp + timeouts[e2->group];
    return t1 < t2 ? -1 : (t1 == t2 ? 0 : 1);
}

/**
 * @brief Set the error if possible and update the timer if necessary
 *
 * @param data The data of the error to set
 */
void _error_set(ErrorData data) {
    // Get error
    Error * err = &errors[data.group][data.instance];
    if (err->is_running || err->is_expired)
        return;

    // Update error info
    err->is_running = true;
    err->timestamp = data.timestamp;

    // Add error to the running list of errors and
    // update timer if the error is the first to expire
    if (!min_heap_insert(&running_errors, &err))
        return;
    Error ** top = (Error **)min_heap_peek(&running_errors);
    if (top != NULL && *top == err)
        error_update_timer_callback(err->timestamp, timeouts[err->group]);
}

/**
 * @brief Reset the error if possible and update the timer if necessary
 *
 * @param data The data of the error to reset
 */
void _error_reset(ErrorData data) {
    // Get error
    Error * err = &errors[data.group][data.instance];
    if (!err->is_running || err->is_expired)
        return;

    // Update error info
    err->is_running = false;

    // Get the current first element
    Error * top = NULL;
    if (!min_heap_top(&running_errors, &top))
        return;

    if (top == err) {
        // If the removed error is the first in the heap
        // remove it and update (or stop) the timer
        if (!min_heap_remove(&running_errors, 0, NULL)) return;
        if (min_heap_is_empty(&running_errors))
            error_stop_timer_callback();
        else if (min_heap_top(&running_errors, &top))
            error_update_timer_callback(top->timestamp, timeouts[top->group]);
    }
    else {
        // Find and remove the error
        ssize_t i = min_heap_find(&running_errors, &top);
        if (i < 0) return;
        min_heap_remove(&running_errors, i, NULL);
    }
}

/**
 * @brief Expire the error
 *
 * @param data The data of the error to expire
 */
void _error_expire(ErrorData data) {
    // Get error
    Error * top = NULL;
    if (!min_heap_top(&running_errors, &top))
        return;

    if (!top->is_running || top->is_expired)
        return;

    Error * prev = top;
    do {
        // Update error info
        top->is_running = false;
        top->is_expired = true;

        // Get next error and remove the previous
        if (!min_heap_remove(&running_errors, 0, NULL))
            break;

        // Stop the timer if there are no more errors
        if (min_heap_is_empty(&running_errors)) {
            error_stop_timer_callback();
            return;
        }

        // Get next errors
        if (!min_heap_top(&running_errors, &top))
            break;
    } while(_error_compare(&top, &prev) <= 0);
    
    // Update the timer
    if (top != NULL)
        error_update_timer_callback(top->timestamp, timeouts[top->group]);
}

void error_init(void) {
    for (size_t i = 0; i < instances[ERROR_FIRST]; ++i)
        error_first_instances[i].group = ERROR_FIRST;
    for (size_t i = 0; i < instances[ERROR_SECOND]; ++i)
        error_second_instances[i].group = ERROR_SECOND;
    for (size_t i = 0; i < instances[ERROR_THIRD]; ++i)
        error_third_instances[i].group = ERROR_THIRD;
}
void error_set(ErrorGroup group, ErrorInstance instance, uint32_t timestamp) {
    if (group >= ERROR_COUNT || instance >= instances[group])
        return;

    // Push data to the buffer
    ErrorData data = {
        .group = group,
        .instance = instance,
        .timestamp = timestamp,
        .op = _error_set
    };
    if (ring_buffer_push_back(&err_buf, &data))
        error_routine();
}
void error_reset(ErrorGroup group, ErrorInstance instance) {
    if (instance >= instances[group])
        return;

    // Push data to the buffer
    ErrorData data = {
        .group = group,
        .instance = instance,
        .timestamp = 0,
        .op = _error_reset
    };
    if (ring_buffer_push_back(&err_buf, &data))
        error_routine();
}
void error_expire(void) {
    // Push data to the buffer
    ErrorData data = { .op = _error_expire };
    if (ring_buffer_push_back(&err_buf, &data))
        error_routine();
}
void error_routine(void) {
    // Avoid multiple execution of the routine
    if (routine_lock)
        return;
    routine_lock = true;

    // Check if buffer is not empty
    if (ring_buffer_is_empty(&err_buf)) {
        routine_lock = false;
        return;
    }

    // Execute the right function for the error
    ErrorData err;
    if (ring_buffer_pop_front(&err_buf, &err))
        err.op(err);

    routine_lock = false;
}

__attribute__((weak)) void error_update_timer_callback(uint32_t timestamp, uint16_t timeout) { }
__attribute__((weak)) void error_stop_timer_callback(void) { }

